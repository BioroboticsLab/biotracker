#ifndef COMPONENTSHAPE_H
#define COMPONENTSHAPE_H

#include "QGraphicsObject" 
#include "Interfaces/IView/IViewTrackedComponent.h"
#include "Interfaces/IModel/IModelTrackedComponent.h"
#include "qpainter.h"
#include "qgraphicsitem.h"
#include "Interfaces/IModel/IModelTrackedTrajectory.h"
#include "Model/CoreParameter.h"
#include "QTime"
#include "View/Utility/RotationHandle.h"


/**
* This class inherits QGraphicsObject.
* It is a child of the TrackedComponentView and is generated by it for
* each trajectory in the tracking data. It visualizes the corresponding entity of the
* trajectory in the current frame of the medium. If there is no tracking data for that frame,
* this shape is hidden. It deletes itself when the trajectory is a nullpointer.
* It contains user interaction functionality to move, remove and rotate the
* corresponding entity or trajectory.
* The form/type is set when created (from entity: ellipse, point, rectangle, polygon)
* It can be changed by the user via the context menu
*/
class ComponentShape : public QGraphicsObject
{
	Q_OBJECT

public:
	//Constructor
	ComponentShape(QGraphicsObject* parent = 0, IModelTrackedTrajectory* trajectory = 0, int id = -1);
	~ComponentShape();

	//QGraphicsItem interface
	QRectF boundingRect() const override;
	void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
	QPainterPath shape() const override;
	bool advance();
	////////////////////////////////


	/**
	* called by view when tracking data was modified
	* updates this with data from new current entity
	* --> rotation, position, etc....
	*/
	bool updateAttributes(uint framenumber);

	/// returns the corresponding traj
	IModelTrackedTrajectory* getTrajectory();

	/// set permission to enable/disable certain user interactions
	void setPermission(std::pair<ENUMS::COREPERMISSIONS, bool> permission);

	/// returns ID of corresponding trajectory
	int getId();

	/// returns swappable permission
	bool isSwappable();
	/// returns removeable permission
	bool isRemovable();
	/// returns rotatable permission
	bool isRotatable();

	/// helper function
	QPoint getOldPos();

	/// attemps to draw tracers, if _tracingStyle is set tracers are drawn
	void trace();

	/// called in constructor to setup the members with default vlaues from coreparameter component
	void setMembers(CoreParameter* coreParams);

	//public members
	int m_currentFramenumber;                                 /**< current visualized framenumber --> entity  */
	//to fix a bug when moving; TODO better
	int m_w;                                                  /**< width of this; if polygon width of bounding rect of polygon */
	int m_h;                                                  /**< height of this; if polygon height of bounding rect of polygon */

	QGraphicsRectItem* m_tracingLayer;						  /**< the layer with all tracers; is counter-rotated if component shape is rotated */


signals:

	/*
	* These are the signals sent to the command component.
	* They are all modifiying the trakcing data.
	* They contain all the data to reverse them (in the commands component).
	*/
	void emitRemoveTrajectory(IModelTrackedTrajectory* trajectory);
	void emitRemoveTrackEntity(IModelTrackedTrajectory* trajectory, uint frameNumber);
	void emitMoveElement(IModelTrackedTrajectory* trajectory, QPoint oldPos, QPoint newPos, uint frameNumber, int sizeOfStackToMove);
	void emitToggleFixTrack(IModelTrackedTrajectory* trajectory, bool toggle);
	void emitEntityRotation(IModelTrackedTrajectory* trajectory, double oldAngleDeg, double newAngleDeg, uint frameNumber);
	/////////////////////////////////////////////

	void emitGoToFrame(int frame);
	/// each user movement gets broadcasted to other shapes
	void broadcastMove();

	public Q_SLOTS:
	//context menu actions 
	//(actions only give trigger signals and therefore can only connect to parameterless slots)
	void changeBrushColor();
	void changePenColor();
	void changeBrushColor(QColor color);
	void changePenColor(QColor color);
	bool removeTrack();
	bool removeTrackEntity();
	void markShape(int penwidth = 0);
	void unmarkShape();
	void toggleFixTrack();
	void createInfoWindow();
	void setObjectNameContext(QString name);
	void morphIntoRect();
	void morphIntoEllipse();
	void morphIntoPoint();
	void morphIntoPolygon();
	//////////////////////////////////////////////


	//Tracing
	void receiveTracingLength(int tracingLength);
	void receiveTracingStyle(QString style);
	void receiveTracingSteps(int steps);
	void receiveTracingTimeDegradation(QString timeDegradation);
	void receiveTracerProportions(float proportion);
	void receiveTracerOrientationLine(bool toggle);
	void receiveTracerFrameNumber(bool toggle);
	//Visual
	void receiveAntialiasing(bool toggle);
	void receiveTransparency(int alpha);
	//Dimensions
	void receiveDimensions(int width, int height);
	void receiveHeight(int height);
	void receiveWidth(int width);
	void setDimensionsToDefault();
	void receiveToggleOrientationLine(bool toggle);
	void receiveShowId(bool toggle);
	void receiveShapeRotation(double angle, bool rotateEntity);
	//Ignore zoom (disabled)
	void receiveIgnoreZoom(bool toggle);


protected:
	//QGraphicsItem interface
	QVariant itemChange(GraphicsItemChange change, const QVariant &value) override;
	void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
	void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;
	void mouseMoveEvent(QGraphicsSceneMouseEvent *event) override;
	void contextMenuEvent(QGraphicsSceneContextMenuEvent *event) override;
	////////////////////////////////

	//constrains angles under 0 or over 360 degrees to [0, 360]
	double constrainAngle(double x);

private:

	/*
	*                         MEMBERS
	*/

	QGraphicsObject *m_parent;

	//permissions
	std::map<ENUMS::COREPERMISSIONS, bool> m_permissions; /**< list of permissions */
	bool m_pMovable;                          /**< permission to move the component shape */
	bool m_pRemovable;                        /**< permission to remove the component shape */
	bool m_pSwappable;                        /**< permission to move the component shape */
	bool m_pRotatable;                        /**< permission to move the component shape */

	//dimensions

	//int m_z;
	int m_wDefault = 20;                  /**< default width, will be set by entity */
	int m_hDefault = 20;                  /**< default height, will be set by entity */
	bool m_useDefaultDimensions;          /**< true, if dimensions were changed by user, they will stay */

	// appearance
	QColor m_penColor;                        /**< border color */
	QColor m_penColorLast;                    /**< last border color */
	QColor m_brushColor;                      /**< fill color */
	int m_transparency;                       /**< transparency of this */
	bool m_marked;                            /**< if marked, border is thick */
	int m_penWidth;                           /**< border_thickness */
	Qt::PenStyle m_penStyle;                  /**< style of border */
	Qt::PenStyle m_penStylePrev;              /**< last stlye of border */
	bool m_antialiasing;                      /**< if true, antialiasing in enabled */

	// tracing
	QString m_tracingStyle;                 /**< tracing style (none, path, arrow, shape) */
	int m_tracingLength;                    /**< sets how many tracers are drawn (history) */
	int m_tracingSteps;                     /**< sets each x'th tracer is drawn */
	QString m_tracingTimeDegradation;       /**< sets tracer color style (default, transparency, false color) */
	float m_tracerProportions;              /**< set the tracers proportion relative to component shape */
	bool m_tracingOrientationLine;          /**< toggles if orientation line is shwon for tracers */
	bool m_tracerFrameNumber;               /**< toggles if tracer's framenumber is shown (very slow) */

	// rotation
	float m_rotation;                        /**< the current rotation of the compontent shape and entity */
	QLineF m_rotationLine;                   /**< the orientation line  */
	RotationHandle* m_rotationHandle;        /**< the handle with wich the user can change the rotation  */
	QGraphicsRectItem* m_rotationHandleLayer;/**< help layer for rotation handle  */
	bool m_orientationLine;                  /**< toggles if _rotationLine is shown */

	// misc
	int m_id;                              /**< the traj's ID  */
	bool m_showId;                         /**< toggles if id is shown in center  */
	IModelTrackedTrajectory* m_trajectory; /**< the corresponding traj  */
	QList<QPolygonF> m_polygons;           /**< list of polygons to draw (if entity inherited from polygon) */
	bool m_fixed;                          /**< if fixed, border is dotted and tracker cannot change traj data */
	//bool m_trajectoryWasActiveOnce;        /**< unused */
	QPoint m_oldPos;                       /**< position before moving by hand  */

	// dragging
	bool m_dragged;                        /**< true if currently dragged  */
	QTime m_mousePressTime;                /**< helper for dragging  */
	QPoint m_mousePressPos;                /**< helper for dragging  */
};


#endif // COMPONENTSHAPE_H
